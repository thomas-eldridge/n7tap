import datetime as dt
import numpy as np
import matplotlib.pyplot as plt # for testing/investigating

class Data:
    def __init__(self, filename):
        self.data_records = []
        self.dummy_records = []
        f = open(filename, 'rb')
        np.fromfile(f, dtype=np.int32, count=1) # ALL FIRST WORDS ARE TESTABLY IDENTICAL AND EXTRANEOUS
        end = False
        while not end:
            block = self.scan_block(f, n_words=2324) # unit test MUST make sure that this n_words is appropriate for all cases
            if self.check_ID(block, True)[0] == 10:
                od_eq = Doc_Rec(block)
                self.documentation_record = od_eq
            elif self.check_ID(block, True)[0] == 11:
                self.data_records.append(Data_Rec(block, od_eq))
            elif self.check_ID(block, True)[0] == 143:  # may change to 15 later
                self.dummy_records.append(Dummy_Rec(block))
                end = True
    def scan_block(self, file_pointer, n_words=2322):
        """Inputs:
            - file_pointer; a variable which points to the memory location of
              a .TAP file opened to be read as binary
            - n_words (default: 2322); the number of words to be interpreted as
              a single scan block
        Reads the next (9288 byte) block of data.
        Returns a list of (2322) 32-bit words, with endianness swapped."""
        words = np.zeros(n_words, dtype=np.int64)
        for i in range(len(words)):
            morphemes = self.get_morphemes(file_pointer)
            word = self.change_end(morphemes)
            words[i] = word
        return words
    def get_morphemes(self, pointer):
        bytes = self.force_signoff(np.fromfile(pointer, dtype=np.int8, count=4))  # each 32-bit word is made of four 8-bit morphemes
        morphemes = np.zeros(bytes.shape, dtype=np.int16)
        for i in range(len(bytes)):
            if bytes[i] != abs(bytes[i]):
                morpheme = self.twos_complement(abs(bytes[i]), 8)
                morphemes[i] = morpheme
            else:
                morphemes[i] = bytes[i]
        return morphemes
    def force_signoff(self, array):
        """Inputs:
            - array; a numpy array, generated by np.fromfile
        Forces the 8-bit numbers read from file into 16-bit placeholders, hence ignoring signbits."""
        new_array = np.zeros(len(array), np.int16)
        for i in range(len(array)):
            new_array[i] = array[i]
        return new_array
    def change_end(self, word_arr):
        """Inputs:
            - word_arr; an array containing the four bytes
              composing the word
        Swaps the byte order so that the endianness of the word is reversed."""
        word = np.zeros(1, dtype=np.int64)  # forces type to handle 31st bit being on
        for i in range(len(word_arr)):
            word[0] = word[0] << 8
            word[0] = word[0] | word_arr[i]
        return word[0]
    def twos_complement(self, value, bitlength):
        """Inputs:
            - value; the raw value of the number to find the compliment of
            - bitlength; the number of bits about which 2's compliment is to be taken
        Returns the 2's compliment of value."""
        new_val = self.flip_bits(value, bitlength)
        new_val += 1
        return new_val
    def flip_bits(self, value, N):
        """Inputs:
            - value; an integer with bit length less than N
            - N; the number of bits about which bits should be flipped
        For an N-bit number, turns the on bits off and the off bits on."""
        bits = np.zeros((N), bool)
        for i in range(len(bits)):
            bits[i] = value & 1
            value = value >> 1
        new_value = 0
        for bit in ~bits[::-1]:
            new_value = new_value << 1
            new_value = new_value | bit
        return new_value
    def check_ID(self, block, error_catching=True):
        """Inputs:
            - block; a block of words, usually 2322 words long
            - error_catching; a boolean representing whether or not
              to raise an error when physical record numbers do not match record IDs
              (default = True)
        Uses external functions to find the ID of this block as either
        a header, data record, or a footer. Returns the ID."""
        foreign_word = block[0]
        physical_record_number = self.do_bitcomp(foreign_word, 20, 31)
        record_ID = self.do_bitcomp(foreign_word, 8, 15)
        if error_catching:
            self.ID_errors(physical_record_number, record_ID)  # raises an error if necessary
        return record_ID, physical_record_number
    def do_bitcomp(self, word, lower_limit, upper_limit):
        """Input:
            - word; the 32-bit word from which bits are to be extracted
            - upper_limit; the index of the most significant bit to consider
            - lower_limit; the index of the least significant bit to consider
        Picks out bits from within a 32-bit word. Returns the decimal value
        of the specific bits as if the bit represented by lower_limit were the
        least significant bit possible."""
        ll = 32 - (upper_limit + 1)
        ul = 32 - (lower_limit + 1)
        bitcomp = self.get_bitcomp(ll, ul)
        retval = word & bitcomp
        retval = retval >> (32 - (ul + 1))  # add 1 to upper_limit - avoids shifting important bit out
        return retval
    def get_bitcomp(self, lower_limit, upper_limit, word_length=32):
        """Input:
            - upper_limit; the index of the most significant bit to be turned on
            - lower_limit; the index of the least significant bit to be turned on
            - word_length (default: 32); the number of bits in a standard word
        Assumes all bits in range are on. Returns a number which can be used
        to pick out bits from within a 32-bit word."""
        bit_arr = np.zeros(word_length, dtype=np.int64)
        bit_arr[lower_limit:upper_limit + 1] = 1  # add 1 to upper_limit - includes endpoint
        bitcomp = 0
        for i in range(len(bit_arr)):
            bitcomp = bitcomp << 1
            bitcomp = bitcomp | bit_arr[i]
        return bitcomp
    def ID_errors(self, number, record_type):
        """Inputs:
            - number; the index of the record in the file
            - record_type; the identifier of the record (10, 11 or 15).
        If the physical record number does not match those permitted
        for the record type, raises an error."""
        error = False
        if record_type == 10:
            if number != 1:
                error = True
            else:
                pass
        elif (record_type == 11) or (record_type == 15):
            if (number <= 1) or (number > 502):
                error = True
            else:
                pass
        else:
            pass
        if error:
            raise ValueError('Record ID %i does not match record number %i' % (record_type, number))
        else:
            print 'record number = %i' % number
        return
    def set_footer(self, swath_block):
        """Inputs:
            - swath_block; a block of THIR data words
        Block words must correspond to a footer (ID=15). Words from the block are set as object attributes."""
        self.add_record(swath_block)

class Doc_Rec:
    def __init__(self, block):
        id, number = self.check_ID(block)
        self.record_number = number
        self.record_id = id
        self.file_number = block[1]
        self.orbit_number = block[2]
        self.start_dt = self.make_datetime(block[3], block[4], block[5])
        self.stop_dt = self.make_datetime(block[6], block[7], block[8])
        self.south_dt = self.make_datetime(block[9], block[10], block[11])
        self.north_dt = self.make_datetime(block[12], block[13], block[14])
        self.descent_lon = block[15]/10.
        self.ascent_lon = block[16]/10.
        self.anode_dt = self.make_datetime(block[17], block[18], block[19])
        self.solar_dec = block[20]/1000. # in degrees
        self.vapour_table = self.make_lookup_table(block[21:149]) # check number of elements
        self.window_table = self.make_lookup_table(block[150:278]) # check number of elements
    def check_ID(self, block):
        """Inputs:
            - block; a block of words, usually 2322 words long
            - error_catching; a boolean representing whether or not
              to raise an error when physical record numbers do not match record IDs
              (default = True)
        Uses external functions to find the ID of this block as either
        a header, data record, or a footer. Returns the ID."""
        foreign_word = block[0]
        physical_record_number = self.do_bitcomp(foreign_word, 20, 31)
        record_ID = self.do_bitcomp(foreign_word, 8, 15)
        return record_ID, physical_record_number
    def do_bitcomp(self, word, lower_limit, upper_limit):
        """Input:
            - word; the 32-bit word from which bits are to be extracted
            - upper_limit; the index of the most significant bit to consider
            - lower_limit; the index of the least significant bit to consider
        Picks out bits from within a 32-bit word. Returns the decimal value
        of the specific bits as if the bit represented by lower_limit were the
        least significant bit possible."""
        ll = 32 - (upper_limit + 1)
        ul = 32 - (lower_limit + 1)
        bitcomp = self.get_bitcomp(ll, ul)
        retval = word & bitcomp
        retval = retval >> (32 - (ul + 1))  # add 1 to upper_limit - avoids shifting important bit out
        return retval
    def get_bitcomp(self, lower_limit, upper_limit, word_length=32):
        """Input:
            - upper_limit; the index of the most significant bit to be turned on
            - lower_limit; the index of the least significant bit to be turned on
            - word_length (default: 32); the number of bits in a standard word
        Assumes all bits in range are on. Returns a number which can be used
        to pick out bits from within a 32-bit word."""
        bit_arr = np.zeros(word_length, dtype=np.int64)
        bit_arr[lower_limit:upper_limit + 1] = 1  # add 1 to upper_limit - includes endpoint
        bitcomp = 0
        for i in range(len(bit_arr)):
            bitcomp = bitcomp << 1
            bitcomp = bitcomp | bit_arr[i]
        return bitcomp
    def make_datetime(self, year, day, msec):
        """Inputs:
            - year; the year in which data was collected
            - day; the day of the year at which data was collected
            - msec; the number of milliseconds since the start of the day
        Makes a datetime object out of the information provided."""
        retval = dt.datetime(year, 01, 01)
        retval += dt.timedelta(days=(int(day)-1))
        retval += dt.timedelta(milliseconds=int(msec)) # confirmed as milliseconds by THIR_spec_user_guide
        return retval
    def make_lookup_table(self, words):
        new_words = np.zeros(2*len(words), float)
        for i in range(len(words)):
            new_words[2*i] = self.do_bitcomp(words[i], 16, 31)/64.
            new_words[(2*i)+1] = self.do_bitcomp(words[i], 0, 15)/64.
        return new_words

class Data_Rec:
    def __init__(self, block, od_eq):
        id, number = self.check_ID(block)
        self.record_number = number
        self.record_id = id
        self.scan_blocks = []
        sub_block = np.delete(block, 0)
        for i in range(10):
            self.scan_blocks.append(Scan_Block(sub_block[231*i:(231*i)+231], od_eq))
        # add engineering and housekeeping data
    def check_ID(self, block):
        """Inputs:
            - block; a block of words, usually 2322 words long
            - error_catching; a boolean representing whether or not
              to raise an error when physical record numbers do not match record IDs
              (default = True)
        Uses external functions to find the ID of this block as either
        a header, data record, or a footer. Returns the ID."""
        foreign_word = block[0]
        physical_record_number = self.do_bitcomp(foreign_word, 20, 31)
        record_ID = self.do_bitcomp(foreign_word, 8, 15)
        return record_ID, physical_record_number
    def do_bitcomp(self, word, lower_limit, upper_limit):
        """Input:
            - word; the 32-bit word from which bits are to be extracted
            - upper_limit; the index of the most significant bit to consider
            - lower_limit; the index of the least significant bit to consider
        Picks out bits from within a 32-bit word. Returns the decimal value
        of the specific bits as if the bit represented by lower_limit were the
        least significant bit possible."""
        ll = 32 - (upper_limit + 1)
        ul = 32 - (lower_limit + 1)
        bitcomp = self.get_bitcomp(ll, ul)
        retval = word & bitcomp
        retval = retval >> (32 - (ul + 1))  # add 1 to upper_limit - avoids shifting important bit out
        return retval
    def get_bitcomp(self, lower_limit, upper_limit, word_length=32):
        """Input:
            - upper_limit; the index of the most significant bit to be turned on
            - lower_limit; the index of the least significant bit to be turned on
            - word_length (default: 32); the number of bits in a standard word
        Assumes all bits in range are on. Returns a number which can be used
        to pick out bits from within a 32-bit word."""
        bit_arr = np.zeros(word_length, dtype=np.int64)
        bit_arr[lower_limit:upper_limit + 1] = 1  # add 1 to upper_limit - includes endpoint
        bitcomp = 0
        for i in range(len(bit_arr)):
            bitcomp = bitcomp << 1
            bitcomp = bitcomp | bit_arr[i]
        return bitcomp

class Dummy_Rec:
    def __init__(self, block):
        id, number = self.check_ID(block)
        self.record_number = number
        self.record_id = id

class Scan_Block:
    def __init__(self, words, od_eq):
        self.nadir_time = self.do_bitcomp(words[0], 16, 31)
        self.flags = self.do_bitcomp(words[0], 0, 15)
        self.radiance_blocks = []
        sub_words = np.delete(words, 0) # removes the first word
        words_as_bytes = self.get_words_as_bytes(sub_words)  # should be 230 words
        for i in range(92):
            self.radiance_blocks.append(Rad_Block(words_as_bytes[10*i:(10*i)+10], od_eq))
    def do_bitcomp(self, word, lower_limit, upper_limit):
        """Input:
            - word; the 32-bit word from which bits are to be extracted
            - upper_limit; the index of the most significant bit to consider
            - lower_limit; the index of the least significant bit to consider
        Picks out bits from within a 32-bit word. Returns the decimal value
        of the specific bits as if the bit represented by lower_limit were the
        least significant bit possible."""
        ll = 32 - (upper_limit + 1)
        ul = 32 - (lower_limit + 1)
        bitcomp = self.get_bitcomp(ll, ul)
        retval = word & bitcomp
        retval = retval >> (32 - (ul + 1))  # add 1 to upper_limit - avoids shifting important bit out
        return retval
    def get_bitcomp(self, lower_limit, upper_limit, word_length=32):
        """Input:
            - upper_limit; the index of the most significant bit to be turned on
            - lower_limit; the index of the least significant bit to be turned on
            - word_length (default: 32); the number of bits in a standard word
        Assumes all bits in range are on. Returns a number which can be used
        to pick out bits from within a 32-bit word."""
        bit_arr = np.zeros(word_length, dtype=np.int64)
        bit_arr[lower_limit:upper_limit + 1] = 1  # add 1 to upper_limit - includes endpoint
        bitcomp = 0
        for i in range(len(bit_arr)):
            bitcomp = bitcomp << 1
            bitcomp = bitcomp | bit_arr[i]
        return bitcomp
    def get_words_as_bytes(self, words):
        """Inputs:
            - words; an array of words to be converted to bytes
        Each word is 32 bits long, so we should broduce 4x as many bytes as words."""
        byte_array = np.zeros(len(words)*4, dtype=np.int16) # should have len = 920
        for i in range(len(words)):
            for j in range(4):
                shifter = 8*j
                bit_selector = 255 << shifter
                byte_array[(4*i)+j] = (words[i] & bit_selector) >> shifter
        return byte_array

class Rad_Block():
    def __init__(self, the_bytes, od):
        self.latitude = self.get_coord(the_bytes[0:2])
        self.longitude = self.get_coord(the_bytes[2:4])
        self.window_rads = []
        self.vapour_rads = []
        self.window_temps = []
        self.vapour_temps = []
        temps_arr = self.lookup_temps(the_bytes[4:], od)
        self.window_rads.append(the_bytes[4]/8.)
        self.window_temps.append(temps_arr[0])
        self.vapour_rads.append(the_bytes[5]/64.)
        self.vapour_temps.append(temps_arr[1])
        self.window_rads.append(the_bytes[6]/8.)
        self.window_temps.append(temps_arr[2])
        self.window_rads.append(the_bytes[7]/8.)
        self.window_temps.append(temps_arr[3])
        self.vapour_rads.append(the_bytes[8]/64.)
        self.vapour_temps.append(temps_arr[4])
        self.window_rads.append(the_bytes[9]/8.)
        self.window_temps.append(temps_arr[5])
    def get_coord(self, coord_bytes):
        word = (coord_bytes[0]<<8)|coord_bytes[1]
        int_part = (word & 0b1111111110000000) >> 7
        float_part = (word & 0b1111111)/128.
        coord = int_part + float_part
        return coord
    def lookup_temps(self, some_bytes, od):
        window_lookup = od.window_table
        vapour_lookup = od.vapour_table
        return_temps = []
        return_temps.append(window_lookup[int(some_bytes[0])])
        return_temps.append(vapour_lookup[int(some_bytes[1])])
        return_temps.append(window_lookup[int(some_bytes[2])])
        return_temps.append(window_lookup[int(some_bytes[3])])
        return_temps.append(vapour_lookup[int(some_bytes[4])])
        return_temps.append(window_lookup[int(some_bytes[5])])
        return return_temps


